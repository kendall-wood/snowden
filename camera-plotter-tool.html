<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Plotter - Snowden Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
        }
        
        #container {
            display: flex;
            gap: 20px;
        }
        
        #canvas-wrapper {
            position: relative;
            border: 2px solid #00ff00;
            max-width: 1000px;
            max-height: 700px;
            overflow: auto;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
            transform-origin: 0 0;
        }
        
        #controls {
            flex: 1;
            background-color: #000;
            padding: 20px;
            border: 2px solid #00ff00;
            max-width: 400px;
        }
        
        h1 {
            color: #00ff00;
            margin-top: 0;
        }
        
        button {
            background-color: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        button:hover {
            background-color: #005500;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #output {
            background-color: #000;
            border: 1px solid #00ff00;
            padding: 10px;
            margin-top: 10px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
        }
        
        .item-info {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #00ff00;
        }
        
        .instructions {
            border: 1px solid #ffff00;
            padding: 10px;
            margin: 10px 0;
            color: #ffff00;
        }
        
        .complete {
            color: #00ff00;
        }
        
        .incomplete {
            color: #ff0000;
        }
        
        input[type="number"] {
            background-color: #000;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 5px;
            font-family: 'Courier New', monospace;
            width: 80px;
        }
        
        label {
            display: inline-block;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h1>Camera Plotter - Snowden Game Level 2</h1>
    
    <div id="container">
        <div id="canvas-wrapper">
            <canvas id="canvas"></canvas>
        </div>
        
        <div id="controls">
            <div class="instructions">
                <strong>INSTRUCTIONS:</strong><br>
                • Existing cameras from game.js are loaded on start<br>
                • Click camera to select/modify it<br>
                • Click map to add new camera<br>
                • Drag from camera to set facing direction<br>
                • Or manually set angle in degrees<br>
                • Click "Generate Code" when done
            </div>
            
            <div id="status-info" class="item-info">
                <strong>Status:</strong><br>
                Cameras Placed: <span id="camera-count">0</span><br>
                <small style="color: #888;">(<span id="existing-count">0</span> loaded from game.js)</small><br><br>
                <strong>Legend:</strong><br>
                <span style="color: #0080ff;">● Blue</span> = Existing cameras<br>
                <span style="color: #ff0000;">● Red</span> = New cameras<br>
                <span style="color: #ffff00;">● Yellow</span> = Selected
            </div>
            
            <div id="current-camera-info" class="item-info" style="display: none;">
                <strong>Selected Camera:</strong><br>
                Position: <span id="cam-pos">-</span><br>
                <label>
                    Facing Angle (degrees):<br>
                    <input type="number" id="angle-input" min="0" max="359" value="0" step="15">
                </label><br>
                <small>0° = Right, 90° = Down, 180° = Left, 270° = Up</small>
            </div>
            
            <div style="border: 1px solid #00ff00; padding: 10px; margin-bottom: 10px;">
                <strong>Zoom:</strong><br>
                <button id="zoom-out-btn">Zoom Out (-)</button>
                <button id="zoom-in-btn">Zoom In (+)</button>
                <button id="fit-btn">Fit to Screen</button>
                <br><span id="zoom-level">25%</span>
            </div>
            
            <button id="delete-btn" disabled>Delete Selected Camera</button>
            <button id="reset-btn">Reset to Existing</button>
            <button id="clear-btn">Clear All Cameras</button>
            <br><br>
            <button id="generate-btn" disabled>Generate Code</button>
            
            <div id="output"></div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        // EXISTING CAMERAS FROM GAME.JS - Edit this array to load different cameras
        const EXISTING_CAMERAS = [
            {x: 4674, y: 2024, facingAngle: 2.3562},  // Camera 1
            {x: 3298, y: 2908, facingAngle: 5.4978},  // Camera 2
            {x: 3846, y: 2424, facingAngle: 0.0000},  // Camera 3
            {x: 2526, y: 1660, facingAngle: 0.7854},  // Camera 4
            {x: 2514, y: 2420, facingAngle: 0.0000},  // Camera 5
            {x: 1218, y: 1660, facingAngle: 0.7854},  // Camera 6
            {x: 1214, y: 3400, facingAngle: 5.4978},  // Camera 7
            {x: 3776, y: 1646, facingAngle: 1.5708},  // Camera 8
            {x: 4865, y: 3398, facingAngle: 3.9270}   // Camera 9
        ];
        
        // Store camera data - Initialize with existing cameras
        let cameras = JSON.parse(JSON.stringify(EXISTING_CAMERAS));  // Deep copy
        let selectedCameraIndex = -1;
        let zoomLevel = 0.25;  // Start at 25% zoom
        let isDragging = false;
        let dragStartCamera = null;
        
        // Load Level 2 map
        img.src = 'assets/lvl-2-map.png';
        
        img.onerror = function() {
            alert('Error loading image! Make sure lvl-2-map.png exists and you\'re running via local server at http://127.0.0.1:8000/camera-plotter-tool.html');
        };
        
        img.onload = function() {
            // Set canvas size to match image at current zoom
            canvas.width = img.width * zoomLevel;
            canvas.height = img.height * zoomLevel;
            redraw();
        };
        
        // Draw everything
        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw map
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Draw cameras
            cameras.forEach((camera, index) => {
                const x = camera.x * zoomLevel;
                const y = camera.y * zoomLevel;
                const radius = 15;
                
                // Determine if this is an existing camera or a new one
                const isExisting = index < EXISTING_CAMERAS.length;
                
                // Camera body (circle)
                if (index === selectedCameraIndex) {
                    ctx.fillStyle = '#ffff00';  // Yellow when selected
                } else if (isExisting) {
                    ctx.fillStyle = '#0080ff';  // Blue for existing cameras
                } else {
                    ctx.fillStyle = '#ff0000';  // Red for new cameras
                }
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Camera outline
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Direction arrow
                const arrowLength = 30;
                const arrowX = x + Math.cos(camera.facingAngle) * arrowLength;
                const arrowY = y + Math.sin(camera.facingAngle) * arrowLength;
                
                ctx.strokeStyle = index === selectedCameraIndex ? '#ffff00' : '#00ff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(arrowX, arrowY);
                ctx.stroke();
                
                // Arrow head
                const headLength = 10;
                const headAngle = Math.PI / 6;
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(
                    arrowX - headLength * Math.cos(camera.facingAngle - headAngle),
                    arrowY - headLength * Math.sin(camera.facingAngle - headAngle)
                );
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(
                    arrowX - headLength * Math.cos(camera.facingAngle + headAngle),
                    arrowY - headLength * Math.sin(camera.facingAngle + headAngle)
                );
                ctx.stroke();
                
                // Camera number
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(index + 1, x, y);
            });
        }
        
        // Handle canvas click/drag
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / zoomLevel;
            const y = (e.clientY - rect.top) / zoomLevel;
            
            // Check if clicking existing camera
            let clicked = false;
            cameras.forEach((camera, index) => {
                const dist = Math.sqrt(Math.pow(camera.x - x, 2) + Math.pow(camera.y - y, 2));
                if (dist < 20) {
                    selectedCameraIndex = index;
                    clicked = true;
                    dragStartCamera = {x: e.clientX, y: e.clientY, camera: camera};
                    isDragging = true;
                }
            });
            
            if (!clicked) {
                // Place new camera
                cameras.push({
                    x: Math.round(x),
                    y: Math.round(y),
                    facingAngle: 0  // Default facing right
                });
                selectedCameraIndex = cameras.length - 1;
            }
            
            updateUI();
            redraw();
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && dragStartCamera) {
                const rect = canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                // Calculate angle from camera center to current mouse position
                const camera = dragStartCamera.camera;
                const cameraScreenX = camera.x * zoomLevel;
                const cameraScreenY = camera.y * zoomLevel;
                
                const angle = Math.atan2(currentY - cameraScreenY, currentX - cameraScreenX);
                camera.facingAngle = angle;
                
                updateUI();
                redraw();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            dragStartCamera = null;
        });
        
        // Update UI
        function updateUI() {
            document.getElementById('camera-count').textContent = cameras.length;
            document.getElementById('existing-count').textContent = EXISTING_CAMERAS.length;
            document.getElementById('generate-btn').disabled = cameras.length === 0;
            document.getElementById('delete-btn').disabled = selectedCameraIndex === -1;
            
            if (selectedCameraIndex >= 0 && selectedCameraIndex < cameras.length) {
                const camera = cameras[selectedCameraIndex];
                document.getElementById('current-camera-info').style.display = 'block';
                document.getElementById('cam-pos').textContent = `(${camera.x}, ${camera.y})`;
                
                // Convert radians to degrees for display
                const degrees = Math.round((camera.facingAngle * 180 / Math.PI + 360) % 360);
                document.getElementById('angle-input').value = degrees;
            } else {
                document.getElementById('current-camera-info').style.display = 'none';
            }
        }
        
        // Angle input change
        document.getElementById('angle-input').addEventListener('input', (e) => {
            if (selectedCameraIndex >= 0) {
                const degrees = parseInt(e.target.value) || 0;
                cameras[selectedCameraIndex].facingAngle = (degrees * Math.PI / 180);
                redraw();
            }
        });
        
        // Delete selected camera
        document.getElementById('delete-btn').addEventListener('click', () => {
            if (selectedCameraIndex >= 0) {
                cameras.splice(selectedCameraIndex, 1);
                selectedCameraIndex = -1;
                updateUI();
                redraw();
            }
        });
        
        // Reset to existing cameras
        document.getElementById('reset-btn').addEventListener('click', () => {
            if (confirm('Reset to existing cameras from game.js? This will discard any changes.')) {
                cameras = JSON.parse(JSON.stringify(EXISTING_CAMERAS));  // Deep copy
                selectedCameraIndex = -1;
                updateUI();
                redraw();
                document.getElementById('output').innerHTML = '';
            }
        });
        
        // Clear all
        document.getElementById('clear-btn').addEventListener('click', () => {
            if (confirm('Clear all cameras?')) {
                cameras = [];
                selectedCameraIndex = -1;
                updateUI();
                redraw();
                document.getElementById('output').innerHTML = '';
            }
        });
        
        // Zoom controls
        function zoomIn() {
            zoomLevel = Math.min(zoomLevel + 0.1, 2.0);
            canvas.width = img.width * zoomLevel;
            canvas.height = img.height * zoomLevel;
            document.getElementById('zoom-level').textContent = Math.round(zoomLevel * 100) + '%';
            redraw();
        }
        
        function zoomOut() {
            zoomLevel = Math.max(zoomLevel - 0.1, 0.1);
            canvas.width = img.width * zoomLevel;
            canvas.height = img.height * zoomLevel;
            document.getElementById('zoom-level').textContent = Math.round(zoomLevel * 100) + '%';
            redraw();
        }
        
        function fitToScreen() {
            const wrapper = document.getElementById('canvas-wrapper');
            const scaleX = (wrapper.clientWidth - 20) / img.width;
            const scaleY = (wrapper.clientHeight - 20) / img.height;
            zoomLevel = Math.min(scaleX, scaleY);
            canvas.width = img.width * zoomLevel;
            canvas.height = img.height * zoomLevel;
            document.getElementById('zoom-level').textContent = Math.round(zoomLevel * 100) + '%';
            redraw();
        }
        
        document.getElementById('zoom-in-btn').addEventListener('click', zoomIn);
        document.getElementById('zoom-out-btn').addEventListener('click', zoomOut);
        document.getElementById('fit-btn').addEventListener('click', fitToScreen);
        
        // Generate code
        document.getElementById('generate-btn').addEventListener('click', () => {
            const output = document.getElementById('output');
            
            let code = '// Security camera positions and facing angles for Level 2\n';
            code += 'cameras: [\n';
            
            cameras.forEach((camera, index) => {
                code += `    {x: ${camera.x}, y: ${camera.y}, facingAngle: ${camera.facingAngle.toFixed(4)}}`;
                if (index < cameras.length - 1) code += ',';
                code += `  // Camera ${index + 1}\n`;
            });
            
            code += ']\n\n';
            code += '// Summary:\n';
            code += `// Total cameras: ${cameras.length}\n`;
            code += '// Add this to LEVEL_CONFIGS[2] in game.js\n';
            
            output.innerHTML = `<pre>${code}</pre>`;
            
            // Also log to console
            console.log(code);
            alert('Code generated! Check the output box and browser console. Copy and paste into your game code.');
        });
        
        // Initialize
        updateUI();
    </script>
</body>
</html>

